const PeerConnectionSettings: RTCConfiguration = {
  // {
  iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
  // },
  // {
  //   optional: [{ DtlsSrtpKeyAgreement: false }],
  // },
};

let pc: RTCPeerConnection;
let offer: RTCSessionDescription;
let answer = null;

function onsignalingstatechange(state) {
  // console.info('signaling state change:', state);
}
function oniceconnectionstatechange(state) {
  // console.info('ice connection state change:', state);
}
function onicegatheringstatechange(state) {
  // console.info('ice gathering state change:', state);
}

function getOffer(pastedOffer) {
  data = JSON.parse(pastedOffer);
  offer = new RTCSessionDescription(data);
  answer = null;

  pc = new RTCPeerConnection(PeerConnectionSettings);
  pc.onsignalingstatechange = onsignalingstatechange;
  pc.oniceconnectionstatechange = oniceconnectionstatechange;
  pc.onicegatheringstatechange = onicegatheringstatechange;
  pc.onicecandidate = function (candidate) {
    // Firing this callback with a null candidate indicates that
    // trickle ICE gathering has finished, and all the candidates
    // are now present in pc.localDescription.  Waiting until now
    // to create the answer saves us from having to send offer +
    // answer + iceCandidates separately.
    if (candidate.candidate == null) {
      doShowAnswer();
    }
  };
  doHandleDataChannels();
}

function makeOffer() {
  pc = new RTCPeerConnection(PeerConnectionSettings);
  makeDataChannel();
  pc.onsignalingstatechange = onsignalingstatechange;
  pc.oniceconnectionstatechange = oniceconnectionstatechange;
  pc.onicegatheringstatechange = onicegatheringstatechange;
  pc.createOffer((desc) => {
    pc.setLocalDescription(desc, () => {});
    // We'll pick up the offer text once trickle ICE is complete,
    // in onicecandidate.
  });
  pc.onicecandidate = function (candidate) {
    // Firing this callback with a null candidate indicates that
    // trickle ICE gathering has finished, and all the candidates
    // are now present in pc.localDescription.  Waiting until now
    // to create the answer saves us from having to send offer +
    // answer + iceCandidates separately.
    if (candidate.candidate == null) {
      console.log('Your offer is:');
      console.log(JSON.stringify(pc.localDescription));
      rl.question('Please paste your answer:\n', (answer) => {
        getAnswer(answer);
      });
    }
  };
}

function makeDataChannel() {
  // If you don't make a datachannel *before* making your offer (such
  // that it's included in the offer), then when you try to make one
  // afterwards it just stays in "connecting" state forever.  This is
  // my least favorite thing about the datachannel API.
  const channel = pc.createDataChannel('test', {
    //  reliable: true
  });
  channel.onopen = function () {
    console.log('\nConnected!');
    inputLoop(channel);
  };
  channel.onmessage = function (evt) {
    data = JSON.parse(evt.data);
    cursor.blue();
    console.log(data.message);
    inputLoop(channel);
  };
  channel.onerror = doHandleError;
}

function getAnswer(pastedAnswer) {
  data = JSON.parse(pastedAnswer);
  answer = new webrtc.RTCSessionDescription(data);
  pc.setRemoteDescription(answer);
}
